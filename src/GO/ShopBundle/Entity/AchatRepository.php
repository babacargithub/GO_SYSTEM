<?php

namespace GO\ShopBundle\Entity;
use GO\ShopBundle\Entity\Shop;
use GO\ShopBundle\Entity\Achat;
use Doctrine\ORM\EntityRepository;
use GO\ShopBundle\Utils\Constants as Cons;
use Symfony\Component\OptionsResolver\OptionsResolver;
use Symfony\Component\OptionsResolver\OptionsResolverInterface;

/**
 * AchatRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class AchatRepository extends EntityRepository
{
    const ACHAT_PAYE=true;
    const ACHAT_NON_PAYE=false;
    const ACHAT_PAYE_ET_NON_PAYE=null;
    const ACHAT_SORTIE_STOCK_LISTE=1,
          ACHAT_SORTIE_STOCK_NOMBRE_DE_FOIS=2,
          ACHAT_SORTIE_STOCK_QUANTITE_TOTAL=3,
          ACHAT_SORTIE_STOCK_TOTAL_VALEUR=4;
    // des constances pour filtrer les entrées 
    const ACHAT_ENTREE_STOCK_LISTE=1,
          ACHAT_ENTREE_STOCK_NOMBRE_DE_FOIS=2,
          ACHAT_ENTREE_STOCK_QUANTITE_TOTAL=3,
          ACHAT_ENTREE_STOCK_TOTAL_VALEUR=4;
            

    public function getListeAchat(Shop $shop, $condition,$achatPaye=self::ACHAT_PAYE,$date_debut=null, $date_fin=null)
    {
        $qb= $this->createQueryBuilder('a');
       
        $qb->join('a.facture', 'f');
        
        switch($condition)
        {
            case Cons::AUJOURDHUI: $qb->where('DATE(a.date)=CURRENT_DATE()');
                break;
            case Cons::MOIS: $qb->where('MONTH(a.date)=MONTH(CURRENT_DATE()) AND YEAR(a.date)=YEAR(CURRENT_DATE())');
                break;
            case Cons::DATE_INTERVALLE: 
                if(!is_null($date_debut))
                {
                    $qb->where('DATE(a.date)>=:date_debut');
                    $qb->setParameter('date_debut', $date_debut);
                    if(!is_null($date_fin))
                    {
                        $qb->andWhere('DATE(a.date)<=:date_fin');
                        $qb->setParameter('date_fin', $date_fin);
                    }
                }else
                {
                    throw new \RuntimeException('Aucune date entrée ou format date invalide!');
                }
                break;
        }
        $qb->addSelect('f');
        if(!is_null($achatPaye))
        {
         $qb->andWhere('f.paye=:paye'); $qb->setParameter('paye', $achatPaye);
        }
         $qb->andWhere('f.shop=:shop');
         $qb->setParameter('shop', $shop);
         $qb->orderBy('a.date', 'DESC');
       
        return $qb->getQuery()
                ->getResult();
    }
    public function getTotalAchat(Shop $shop, $condition,$achatPaye=true,$date_debut=null, $date_fin=null)
    {
        $qb= $this->createQueryBuilder('a')
                
                ->join('a.facture', 'f')
                ->select('SUM(a.prixUnit*a.quantite)');
         switch($condition)
        {
            case Cons::AUJOURDHUI: $qb->where('DATE(a.date)=CURRENT_DATE()');
                break;
            case Cons::MOIS: $qb->where('MONTH(a.date)=MONTH(CURRENT_DATE()) AND YEAR(a.date)=YEAR(CURRENT_DATE())');
                break;
            case Cons::DATE_INTERVALLE: 
                if(!is_null($date_debut))
                {
                    $qb->where('DATE(a.date)>=:date_debut');
                    $qb->setParameter('date_debut', $date_debut);
                    if(!is_null($date_fin))
                    {
                        $qb->andWhere('DATE(a.date)<=:date_fin');
                        $qb->setParameter('date_fin', $date_fin);
                    }
                }else
                {
                    throw new \RuntimeException('Aucune date entrée ou format date invalide!');
                }
                break;
        }
        $qb->andWhere('f.paye=:paye'); $qb->setParameter('paye', $achatPaye);
                $qb->andWhere('f.shop=:shop');
                $qb->setParameter('shop', $shop);
               return $qb->getQuery()->getSingleScalarResult();
        
    }
    public function findByCodeBar(Shop $shop,$codeBar, array $options=array())
    {
        $resolver=new OptionsResolver();
        $this->configureOptions($resolver);
        $options=$resolver->resolve($options);
          $qb= $this->createQueryBuilder('a')
          ->join('a.facture', 'f')
          ->where("a.codeBar=:code_bar")
          ->setParameter("code_bar",$codeBar)
          ->andWhere("f.shop=:shop")
          ->setParameter("shop",$shop)
                  ->getQuery()->getResult();

          if(!empty($qb))
          {
              if($options['findAll']==true)
              {
                  return $qb;
              }if(count($qb)>1)
              {
                  foreach($qb as $achat)
                  {
                      if($achat->getQuantiteRestant()>0)
                      {
                          return $achat;
                      }
                  }
              }
              //cette option findAll permet de retourner tous les produits qui ont le même code barre
              
              return $qb[0];
          }
          else
              return null;
          
    }
    public function getTotalStockCodeBar(Shop $shop,$codeBar)
    {
       $qb= $this->createQueryBuilder("a")->select("SUM(a.quantiteRestant) as quantite")
                ->join('a.facture', 'f')
          ->where("a.codeBar=:code_bar")
          ->setParameter("code_bar",$codeBar)
          ->andWhere("f.shop=:shop")
          ->setParameter("shop",$shop);
                  return (int) $qb->getQuery()->getSingleScalarResult();
    }
    public function venteSurMultiStockCodeBar(Shop $shop,$achat,$quantite)
    {
        //var_dump($shop,$achat,$quantite);die();
       $qb= $this->createQueryBuilder("a")
          ->join('a.facture', 'f')
          ->where("a.codeBar=:code_bar")
          ->setParameter("code_bar",$achat->getCodeBar())
          ->andWhere("f.shop=:shop")
          ->andWhere("a.quantiteRestant > 0")
          ->setParameter("shop",$shop);
            $stocks=$qb->getQuery()->getResult();
            // on récupère l'ensemble des stocks du code barre non vides on les réduit un par un jusqu'à ce que la quantite de la vente
            //est inférieur ou égale à 0
                  $updatedStocks=array();
                  //var_dump($stocks);die();
                  $quantiteRestant=$quantite;
                  foreach ($stocks as $stock)
                  {
                     if($stock->isStockDispo($quantiteRestant))
                     {
                         $stock->diminuer($quantiteRestant);
                         array_push($updatedStocks, $stock);
                         break;
                     }else
                     {
                         $tempQnt=$stock->getQuantite();
                         $quantiteRestant=$quantiteRestant-$tempQnt;
                         $stock->diminuer($tempQnt);
                         array_push($updatedStocks, $stock);
                     }
                     
                     if($quantiteRestant<=0)
                     {
                         break;
                     }
                  }
                  //var_dump($updatedStocks);die();
         return $updatedStocks;
    }

    public function getValeurStockCodeBar(Shop $shop)
    {
        $qb= $this->createQueryBuilder('a')
                
                ->join('a.facture', 'f')
                ->select('SUM(a.prixUnit*a.quantiteRestant)');
                $qb->where('a.codeBar IS NOT NULL');
                $qb->andWhere('f.shop=:shop')->setParameter('shop', $shop);
               return $qb->getQuery()->getSingleScalarResult();
        
    }
    
    protected function configureOptions(OptionsResolverInterface $resolver)
    {
       $resolver->setDefaults(array("findAll"=>false, "findOne"=>false));
    }
   
 
        
    //cette fonction permet de trouver la liste des entrées d'un stock avec code barre
    //new in v 2.1.0
  public function getEntrees(Shop $shop,$codeBar,$filter=self::ACHAT_ENTREE_STOCK_LISTE){
      if(null==$codeBar)
      {
          throw new \Exception("Le code barre pour chercher des entrées de stock ne peut être null!");
      }
      
      
        $qb= $this->createQueryBuilder("a")
                ->join("a.facture", "f")
                 ->where("f.shop=:shop")
                 ->andWhere("a.codeBar=:codeBar")
                ->setParameter("shop", $shop)
                ->setParameter("codeBar", $codeBar);
        switch($filter)
        {
        case self::ACHAT_ENTREE_STOCK_LISTE:
                $qb->select("a");
                return   $qb->getQuery()->getResult();
            break;
        case self::ACHAT_ENTREE_STOCK_NOMBRE_DE_FOIS:
            
                $qb->select("COUNT(a.id)");
            return   (int) $qb->getQuery()->getSingleScalarResult();
            break;
        case self::ACHAT_ENTREE_STOCK_QUANTITE_TOTAL:
            
                $qb->select("SUM(a.quantite)");
            return  (int) $qb->getQuery()->getSingleScalarResult();
            break;
        case self::ACHAT_ENTREE_STOCK_TOTAL_VALEUR:
                $qb->select("SUM(a.quantite*a.prixUnit)");
            return   (int) $qb->getQuery()->getSingleScalarResult();
            break;
        default : 
            // si un filtre inconnu est passé à la fonction, une exception doit être lancée
            throw new \Exception("Flitre des entrées stocks inconnu!");
        }
        //return $qb->getQuery()->getResult();
    
    }
    //cette fonction permet de trouver la liste des ventes effectuées sur un stock avec code barre
    //new in v 2.1.0
    // le filtre permet de parametre la valeur de retour de la fonction
    public function getSorties(Shop $shop,Achat $achat, $filter=self::ACHAT_SORTIE_STOCK_LISTE){
        $qb= $this->createQueryBuilder("a")
                ->join("a.facture", "f")
                ->innerJoin("GO\ShopBundle\Entity\Vente", "v", "WITH", "v.codeBar=a.id")
                ->where("f.shop=:shop")->setParameter("shop", $shop)
                      //->andWhere("v.codeBar=:codeBarId")
                      ->andWhere("a.codeBar=:codeBarId")
                       ->setParameter("codeBarId", $achat->getCodeBar());
        switch($filter)
        {
        case self::ACHAT_SORTIE_STOCK_LISTE:
                $qb->select("v");
                return   $qb->getQuery()->getResult();
            break;
        case self::ACHAT_SORTIE_STOCK_NOMBRE_DE_FOIS:
            
                $qb->select("COUNT(v.id)");
            return   (int) $qb->getQuery()->getSingleScalarResult();
            break;
        case self::ACHAT_SORTIE_STOCK_QUANTITE_TOTAL:
            
                $qb->select("SUM(v.quantite)");
            return  (int) $qb->getQuery()->getSingleScalarResult();
            break;
        case self::ACHAT_SORTIE_STOCK_TOTAL_VALEUR:
                $qb->select("SUM(v.quantite*a.prixUnit)");
            return   (int) $qb->getQuery()->getSingleScalarResult();
            break;
        default : 
            // si un filtre inconnu est passé à la fonction, une exception doit être lancée
            throw new \Exception("Flitre des sorties stocks inconnu!");
                
        }
              ///return   $qb->getQuery()->getResult();
    }
}
